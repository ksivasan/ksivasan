
---
title: "Expectation Maximization"
author: "Kumaraguru Sivasankaran"
date: "October 23, 2018"
output:
  html_document: default
  pdf_document: default
---
## Problem 2

1. Loading MNIST data

```{r Load data}
#library(R.utils)
#R.utils::gunzip("train-images-idx3-ubyte.gz")
#R.utils::gunzip("train-labels-idx1-ubyte.gz")
#R.utils::gunzip("t10k-images-idx3-ubyte.gz")
#R.utils::gunzip("t10k-labels-idx1-ubyte.gz")

load_mnist <- function() {
  load_image_file <- function(filename) {
    ret = list()
    f = file(filename,'rb')
    readBin(f,'integer',n=1,size=4,endian='big')
    ret$n = readBin(f,'integer',n=1,size=4,endian='big')
    nrow = readBin(f,'integer',n=1,size=4,endian='big')
    ncol = readBin(f,'integer',n=1,size=4,endian='big')
    x = readBin(f,'integer',n=ret$n*nrow*ncol,size=1,signed=F)
    ret$x = matrix(x, ncol=nrow*ncol, byrow=T)
    close(f)
    ret
  }
  load_label_file <- function(filename) {
    f = file(filename,'rb')
    readBin(f,'integer',n=1,size=4,endian='big')
    n = readBin(f,'integer',n=1,size=4,endian='big')
    y = readBin(f,'integer',n=n,size=1,signed=F)
    close(f)
    y
  }
  train <<- load_image_file('train-images-idx3-ubyte')
  test <<- load_image_file('t10k-images-idx3-ubyte')
  
  train$y <<- load_label_file('train-labels-idx1-ubyte')
  test$y <<- load_label_file('t10k-labels-idx1-ubyte')  
}


show_digit <- function(arr784, col=gray(12:1/12), ...) {
  image(matrix(arr784, nrow=28)[,28:1], col=col, ...)
}

load_mnist()
show_digit(train$x[10,])
```

Like mentioned in the question, here we create a new dataset containing only twos and threes. This can be extended to any given label set in general.
```{r Creating new dataset}
# create new list
prob_data <- function (label_list){
    prob2 = list()
    # find position of labels 2 and 3
    prob2$interestlabel = label_list
    prob2$position = which(train$y %in% prob2$interestlabel)
    # set n
    prob2$n = length(prob2$position)
    # extract x for given y
    prob2$x = train$x[prob2$position,]
    # extract true label info
    prob2$y = train$y[prob2$position]
    # set threshold on data to make it binary without for loop
    prob2$x[prob2$x<=5] <- 0
    prob2$x[prob2$x>5] <- 1
    prob2$probability = table(prob2$y)
    prob2$probability = prob2$probability/sum(prob2$probability)
    return (prob2)
} 
```

2. Given N observations X = $(x_1, x_2, \dots x_N)$ and their cluster assignments C = $(c_1, c_2 , \dots, c_N)$, the log joint probability is calculated as follows starting with Bernoulli vector and including the mixture probabilities.
\begin{align}
P(x_i|\mu_k) &= \Pi^{784}_{j=1}(\mu_{j}^k)^{(x_j^i)}(1-\mu_{j}^k)^{(1-x_j^i)}\\
P(x_i, c_i=k|\mu_k,\pi_k) &= \pi_k\Pi^{784}_{j=1}(\mu_{j}^k)^{(x_j^i)}(1-\mu_{j}^k)^{(1-x_j^i)}\\
P(x_i, c_i|\mu,\pi) &= \Pi_{k=1}^K[\pi_k\Pi^{784}_{j=1}(\mu_{j}^k)^{(x_j)}(1-\mu_{j}^k)^{(1-x_j)}]^{\delta (c_i=k)}\\
P(X, C|\mu,\pi) &= \Pi_{i=1}^N\Pi_{k=1}^K[\pi_k\Pi^{784}_{j=1}(\mu_{j}^k)^{(x_j^i)}(1-\mu_{j}^k)^{(1-x_j^i)}]^{\delta (c_i=k)}\\
\text{log P}(X,C|\pi,\mu) &= \sum_{i=1}^{N}\sum_{k=1}^K\delta(c_i=k)[\text{log }\pi_k+ \sum_{j=1}^{784}[(x_j^i) \text{log } \mu_j^k + (1-x_j^i) \text{log } (1-\mu_j^k)]]\\
\end{align}
3. If X and C are observed, we get the maximum likelihood of $\pi$ and $\mu^k$ as 
\begin{align}
\pi_k = \frac{\sum_{i=1}^N \delta(c_i=k)}{N} \text{   } &\forall k \\
\mu^k = \frac{\sum_{i=1}^N\delta(c_i=k)x_i}{\sum_{i=1}^N\delta(c_i=k)}\text{   } &\forall k
\end{align}
4. Explain why $P(C|X,\pi,\mu) = \Pi ^N_{i=1}p(c_i|x_i,\pi,\mu)$.
Since we know the samples are independent, we know $P(C|X,\pi,\mu) = \Pi_{i=1}^N P(c_i|X,\pi,\mu)$. The probability of $i^{th}$ sample belonging to a certain class is independent of the entire dataset X but $x_i, \pi, \mu$. Hence, we can rewrite it as $P(C|X,\pi,\mu) = \Pi_{i=1}^N P(c_i|x_i,\pi,\mu)$. Now, 
\begin{align}
P(c_i|x_i,\pi,\mu) &= \frac{P(c_i,x_i|\pi,\mu) }{P(x_i|\pi,\mu) }\\
&= \frac{P(c_i,x_i|\pi,\mu) }{\sum_{c_i}P(c_i,x_i|\pi,\mu) }\\
&=  \frac{P(c_i|\pi)*P(x_i|\mu) }{\sum_{c_i}P(c_i,x_i|\pi,\mu) }\\
&\approx  P(c_i|\pi)*P(x_i|\mu) \\
&= \Pi_{k=1}^K [\pi_k \Pi_{j=1}^{784} \mu_{jk}^{x^i_j}(1-\mu_{jk})^{1-x^i_j}]^{\delta(c_i=k)}\\
P(c_i|x_i,\pi,\mu)&\approx \Pi_{k=1}^K [\pi_k \Pi_{j=1}^{784} \mu_{jk}^{x^i_j}(1-\mu_{jk})^{1-x^i_j}]^{\delta(c_i=k)}\\
\end{align}

5. Variational lower bound $\mathcal{F} (q,\pi,\mu)=\sum_{i=1}^{N} E_{q_i}[\text{log}(P(x_i,c_i|\pi,\mu))] + \sum_{i=1}^N H(q_i)$ where entropy  $H(q_i)=\sum_{c_i}q_i(c_i=k) \text{log}(q_i(c_i=k))$. 
$$\mathcal{F} (q,\pi,\mu)=\sum_{i=1}^{N} \sum^K_{k=1}q_{ik}[\text{log}(P(x_i,c_i=k|\pi,\mu))] + \sum_{i=1}^N H(q_i)$$
$$\mathcal{F} (q,\pi,\mu)=\sum_{i=1}^{N} \sum^K_{k=1}q_{ik} [\text{log }\pi_k+ \sum_{j=1}^{784}[(x_j^i) \text{log } \mu_j^k + (1-x_j^i) \text{log } (1-\mu_j^k)]]+ \sum_{i=1}^N H(q_i)$$



6. For this part, we set $\forall k$
\begin{align}
\frac{\partial \mathcal {F}}{\partial \pi_k}&=0\\
\frac{\partial}{\partial\pi_k}[\sum_{i=1}^N \sum_{k=1}^K q_{ik} \text{log }\pi_k]&=0\\
\frac{\partial}{\partial\pi_k}[\sum_{i=1}^N (\sum_{k=1}^{K-1} q_{ik} \text{log }\pi_k + (1-q_{ik}) \text{log }(1-\pi_{k}))&=0\\
\sum_{i=1}^N ( \frac{q_{ik}}{\pi_k} + \frac{-(1-q_{ik})}{(1-\pi_{k})})&=0\\
\sum_{i=1}^N  (\frac{q_{ik}-q_{ik}\pi_k}{\pi_k(1-\pi_{k})} +  \frac{-\pi_k+\pi_kq_{ik}}{\pi_k(1-\pi_{k})})&=0\\
\sum_{i=1}^N  \frac{q_{ik}-\pi_k}{\pi_k(1-\pi_{k})}&=0\\
\sum_{i=1}^N  \frac{q_{ik}}{\pi_k(1-\pi_{k})}&=\sum_{i=1}^N  \frac{\pi_k}{\pi_k(1-\pi_{k})}\\
\sum_{i=1}^N  q_{ik}&=\pi_k\sum_{i=1}^N \\
\pi_k &=\frac{1}{N} \sum_{i=1}^N  q_{ik}  \\
\end{align}

For this part, we set $\forall j,k$
\begin{align}
\frac{\partial \mathcal {F}}{\partial \mu_{j}^k} &= 0\\
\sum_{i=1}^{N}(q_{ik}[\frac{x_j^i}{\mu_j^k}-\frac{1-x_j^i}{1-\mu_j^k}]) &=0\\
\sum_{i=1}^{N}\frac{q_{ik}(x_j^i)}{\mu_j^k}&=\sum_{i=1}^{N}\frac{q_{ik}(1-x_j^i)}{1-\mu_j^k}\\
(1-\mu_j^k)\sum_{i=1}^{N}q_{ik}(x_j^i)&=\mu_j^k\sum_{i=1}^{N}(q_{ik}-q_{ik}(x_j^i))\\
\sum_{i=1}^{N}q_{ik}(x_j^i)&=\mu_j^k\sum_{i=1}^{N}q_{ik}\\
\mu_j^k&=\frac{\sum_{i=1}^{N}q_{ik}(x_j^i)}{\sum_{i=1}^{N}q_{ik}}\\
\mu^k&=\frac{\sum_{i=1}^{N}q_{ik}(x^i)}{\sum_{i=1}^{N}q_{ik}}\\
\end{align}


```{r part 7}
Bernoulli <- function (xvec, muvec){
  pos = muvec>0
  xvec = xvec[pos]
  muvec = muvec[pos]
  bernoulli_prob = exp(sum(xvec*log(muvec)+(1-xvec)*log(1-muvec)))
  return (bernoulli_prob)
} 
EMalgorithm <-function(prob2){
  set.seed(10)
  prob2$pred = sample(prob2$interestlabel, prob2$n, replace=TRUE)
  prob2$uniqueclass = unique(prob2$y)
  K = length(prob2$uniqueclass)
  prob2$pi = runif(K)
  prob2$pi = prob2$pi/sum(prob2$pi)
  prob2$q = matrix(rep(0,K*prob2$n), ncol=K)
  prob2$qt = matrix(rep(0,K*prob2$n), ncol=K)
  prob2$mu = matrix(sample(c(10:90),784*K, replace=TRUE), nrow = length(prob2$uniqueclass))/100
  prob2$qclass = rep(0,K)
  maxIter = 50
  prob2$FreeEnergy = rep(-10,maxIter)
  prob2$Likelihood = rep(-10,maxIter)
  prob2$EntropyIndividual = rep(1,prob2$n)
  prob2$Entropy = rep(0,maxIter)
  DiffFreeEnergy = 1000
  iter = 1
  while (iter <= maxIter && abs(DiffFreeEnergy) > 1){
    #print("E step")
    for (i in 1:prob2$n){
      for (k in 1:K){
        prob2$qt[i,k]= prob2$pi[k]*(Bernoulli(prob2$x[i,], prob2$mu[k,])) 
      }
      prob2$q[i,] = prob2$qt[i,]/sum(prob2$qt[i,])
      prob2$pred[i] = prob2$uniqueclass[which(prob2$q[i,]==max(prob2$q[i,]))]
    }
    Likelihood_prep = 0
    for (class in 1:K){
      dummy = prob2$qt[,class]
      pos = dummy > 0
      qnonzero = prob2$q[,class]
      Likelihood_prep = Likelihood_prep+sum(qnonzero[pos]*log(dummy[pos]))
    }
    prob2$Likelihood[iter] = Likelihood_prep
    for (enti in 1:prob2$n){
      nonzero_q = prob2$q[enti,1]
      nonzero_q = nonzero_q[nonzero_q>0]
      prob2$EntropyIndividual[enti] = -sum(nonzero_q*log(nonzero_q))   
    }
    prob2$Entropy[iter] = sum(prob2$EntropyIndividual)
    prob2$FreeEnergy[iter] = prob2$Likelihood[iter] + prob2$Entropy[iter]
    if (iter > 1){
      prob2$DiffFreeEnergy = prob2$FreeEnergy[iter]-prob2$FreeEnergy[iter-1] 
    }
    #print(prob2$FreeEnergy[iter])
    #print("M step")
    prob2$qclass = colSums(prob2$q)
    prob2$pi = prob2$qclass/prob2$n
    for (k in 1:K){
      prob2$mu[k,] = colSums(prob2$q[,k]*prob2$x)/prob2$qclass[k]
    }
    iter = iter+1
  }
  cat("Iteration:",iter)
  cat("\n")
  #print(prob2$pi)
  for (mu_i in 1:K){
    show_digit(prob2$mu[mu_i,])
  }
  prob2$error = prob2$pred - prob2$y
  prob2$accuracy = length(prob2$error[prob2$error==0])/length(prob2$error)
  prob2$FreeEnergy = prob2$FreeEnergy[1:iter-1]
  prob2$Likelihood = prob2$Likelihood[1:iter-1]
  prob2$Entropy = prob2$Entropy[1:iter-1]
  plot(prob2$FreeEnergy, xlab="Iteration", ylab="Variational Free Energy")
  #plot(Likelihood)
  #plot(Entropy)
  cat("Pi =",prob2$pi)
  cat("\n")
  cat("Free energy:",prob2$FreeEnergy[length(prob2$FreeEnergy)])
  cat("\n")
  prob2$EntropyIndividual = rep(1,prob2$n)
  for (ient in 1:prob2$n){
    nonzero_q = prob2$q[ient,1]
    nonzero_q = nonzero_q[nonzero_q>0]
    prob2$EntropyIndividual[ient] = -sum(nonzero_q*log(nonzero_q))   
  }
  maxEntropy = which(prob2$EntropyIndividual==max(prob2$EntropyIndividual))
  cat("The parameter vectors are printed followed by digit having maximum entropy")
  show_digit(prob2$x[maxEntropy,])
  return (prob2)
}
```
```{r main1, cache=TRUE}
prob2 <- prob_data(c(2:3))
prob2 <- EMalgorithm(prob2)
```
```{r main2, cache=TRUE}
prob3 <- prob_data(c(2:4))
prob3 <- EMalgorithm(prob3)
```

The units of F- Variational Free energy is same as that of entropy. Entropy can be defined as the measurement of information carried by a probability distribution. It is also the average rate at which information is produced by a stochastic source of data. The unit of entropy depends on the base of the logarithm that is defined to calculate entropy. In our case, we used natural logarithm (base of e) and hence we have the unit as nat for Entropy and variational Free Energy.  In general, if n outcomes are possible for an event, then $log_2(n)$ bits would be required to represent the variable defining the event. In this problem, we have N independent samples with each possible of taking K class values. Hence, $N^K$ possibilities exist and entropy gives an expected value for how many nats (or appropriate unit) required for defining the outcome of this event.
